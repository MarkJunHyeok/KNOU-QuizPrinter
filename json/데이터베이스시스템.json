[
  {
    "question_number": 1,
    "question": "데이터베이스의 가장 큰 장점으로 옳은 것은?",
    "choices": {
      "①": "데이터 중복성 증가",
      "②": "데이터 무결성 보장",
      "③": "데이터 종속성 강화",
      "④": "데이터 은닉"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 2,
    "question": "파일 처리 시스템의 한계가 아닌 것은?",
    "choices": {
      "①": "데이터 종속",
      "②": "데이터 중복",
      "③": "데이터 독립성 확보",
      "④": "보안 취약"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 3,
    "question": "데이터 독립성이란?",
    "choices": {
      "①": "사용자마다 다른 데이터를 제공하는 것",
      "②": "논리 구조와 물리 구조를 분리하는 것",
      "③": "데이터를 암호화하는 것",
      "④": "데이터를 정렬하는 방식"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 4,
    "question": "DBMS의 주요 기능으로 가장 적절하지 않은 것은?",
    "choices": {
      "①": "데이터 저장 및 검색",
      "②": "데이터 보안 제공",
      "③": "데이터 백업 및 회복",
      "④": "데이터 분석 자동화"
    },
    "correct_answer": "④"
  },
  {
    "question_number": 5,
    "question": "3단계 스키마 구조에서 '개념 스키마'는 무엇을 설명하는가?",
    "choices": {
      "①": "물리적 저장 방식",
      "②": "사용자 개별 관점",
      "③": "데이터베이스 전체 논리 구조",
      "④": "네트워크 연결 구조"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 6,
    "question": "데이터베이스의 자기 기술적 성질이 의미하는 것은?",
    "choices": {
      "①": "데이터가 사용자 없이도 자동 정렬됨",
      "②": "메타데이터가 데이터베이스 내에 저장됨",
      "③": "데이터가 중복 저장됨",
      "④": "데이터가 여러 위치에 복사됨"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 7,
    "question": "다음 중 메타데이터에 해당하는 정보는?",
    "choices": {
      "①": "고객 이름",
      "②": "주문 금액",
      "③": "테이블 구조 정의",
      "④": "제품 수량"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 1,
    "question": "ER 모델에서 엔터티(Entity)의 정의로 가장 적절한 것은?",
    "choices": {
      "①": "관계의 속성",
      "②": "현실 세계에서 독립적으로 존재하는 객체",
      "③": "데이터베이스 내부의 논리적 구조",
      "④": "사용자 인터페이스"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 2,
    "question": "다음 중 관계(Relationship)에 해당하는 것은?",
    "choices": {
      "①": "학생",
      "②": "과목",
      "③": "수강",
      "④": "성별"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 3,
    "question": "ER 다이어그램에서 관계를 표현하는 도형은?",
    "choices": {
      "①": "사각형",
      "②": "마름모",
      "③": "타원",
      "④": "삼각형"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 4,
    "question": "개체 타입의 구분 중, 기본 키 없이 다른 개체에 의존하는 개체는?",
    "choices": {
      "①": "강한 개체",
      "②": "복합 개체",
      "③": "약한 개체",
      "④": "중복 개체"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 5,
    "question": "속성(Attribute)에 대한 설명으로 옳지 않은 것은?",
    "choices": {
      "①": "속성은 개체의 특성을 표현한다.",
      "②": "속성은 항상 유일해야 한다.",
      "③": "속성은 기본 속성과 유도 속성으로 나뉜다.",
      "④": "속성은 단순 속성과 복합 속성으로 나뉜다."
    },
    "correct_answer": "②"
  },
  {
    "question_number": 6,
    "question": "ER 모델에서 기본 키 역할을 하는 속성의 표현 방식은?",
    "choices": {
      "①": "이중 타원",
      "②": "밑줄",
      "③": "굵은 선",
      "④": "점선 사각형"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 7,
    "question": "1:N 관계를 관계형 모델로 변환할 때 외래 키를 배치할 위치는?",
    "choices": {
      "①": "1측 개체에 삽입",
      "②": "N측 개체에 삽입",
      "③": "별도 테이블로 생성",
      "④": "두 테이블 모두 삽입"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 1,
    "question": "관계형 데이터 모델에서 하나의 행(row)을 무엇이라고 하는가?",
    "choices": {
      "①": "속성",
      "②": "릴레이션",
      "③": "튜플",
      "④": "도메인"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 2,
    "question": "릴레이션의 열(column)은 무엇을 의미하는가?",
    "choices": {
      "①": "튜플",
      "②": "속성",
      "③": "기본키",
      "④": "스키마"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 3,
    "question": "기본키(primary key)의 가장 중요한 특징은?",
    "choices": {
      "①": "중복을 허용한다",
      "②": "NULL 값을 가질 수 있다",
      "③": "튜플을 유일하게 식별한다",
      "④": "관계를 연결하지 않는다"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 4,
    "question": "외래키(Foreign Key)의 목적은?",
    "choices": {
      "①": "데이터 압축",
      "②": "속성 이름 지정",
      "③": "다른 테이블과의 참조 관계 설정",
      "④": "테이블 병합"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 5,
    "question": "도메인의 정의로 옳은 것은?",
    "choices": {
      "①": "관계형 연산자 집합",
      "②": "속성이 가질 수 있는 값들의 집합",
      "③": "기본키와 외래키의 조합",
      "④": "테이블 간 연산 방식"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 6,
    "question": "다음 중 NULL 값에 대한 설명으로 가장 적절한 것은?",
    "choices": {
      "①": "값이 0이라는 의미",
      "②": "알 수 없는 값 또는 해당 없음",
      "③": "빈 문자열을 의미",
      "④": "필수 입력값"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 7,
    "question": "릴레이션의 스키마에 대한 설명으로 옳지 않은 것은?",
    "choices": {
      "①": "릴레이션의 이름과 속성 집합으로 구성된다",
      "②": "데이터의 구조를 정의한다",
      "③": "릴레이션의 모든 행을 포함한다",
      "④": "릴레이션의 속성 타입을 포함한다"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 1,
    "question": "MySQL에서 데이터베이스를 생성하는 명령어는?",
    "choices": {
      "①": "CREATE DATABASE",
      "②": "MAKE DATABASE",
      "③": "NEW DATABASE",
      "④": "INIT DATABASE"
    },
    "correct_answer": "①"
  },
  {
    "question_number": 2,
    "question": "MySQL에서 테이블 구조를 확인할 수 있는 명령어는?",
    "choices": {
      "①": "CHECK TABLE",
      "②": "DESC 테이블명",
      "③": "SHOW 구조",
      "④": "DISPLAY 테이블"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 3,
    "question": "MySQL에서 기본 키를 설정할 때 사용하는 키워드는?",
    "choices": {
      "①": "UNIQUE KEY",
      "②": "PRIMARY KEY",
      "③": "FOREIGN KEY",
      "④": "IDENTITY KEY"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 4,
    "question": "다음 중 MySQL의 자료형으로 가장 적절한 것은?",
    "choices": {
      "①": "integer()",
      "②": "string",
      "③": "VARCHAR",
      "④": "textual"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 5,
    "question": "MySQL에서 테이블 삭제 명령어는?",
    "choices": {
      "①": "REMOVE TABLE",
      "②": "DELETE TABLE",
      "③": "DROP TABLE",
      "④": "CLEAR TABLE"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 6,
    "question": "MySQL에서 조건을 설정할 때 사용하는 명령어는?",
    "choices": {
      "①": "WHERE",
      "②": "IF",
      "③": "CHECK",
      "④": "WHICH"
    },
    "correct_answer": "①"
  },
  {
    "question_number": 7,
    "question": "MySQL에서 테이블 목록을 확인하는 명령어는?",
    "choices": {
      "①": "SHOW ALL",
      "②": "SHOW TABLES",
      "③": "LIST TABLES",
      "④": "DISPLAY TABLES"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 1,
    "question": "SQL에서 데이터를 조회할 때 사용하는 명령어는?",
    "choices": {
      "①": "SELECT",
      "②": "FIND",
      "③": "GET",
      "④": "LOOKUP"
    },
    "correct_answer": "①"
  },
  {
    "question_number": 2,
    "question": "다음 중 SQL의 데이터 정의어(DDL)에 해당하는 것은?",
    "choices": {
      "①": "SELECT",
      "②": "INSERT",
      "③": "CREATE",
      "④": "UPDATE"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 3,
    "question": "다음 중 SQL에서 조건을 설정하는 절은?",
    "choices": {
      "①": "FROM",
      "②": "GROUP BY",
      "③": "WHERE",
      "④": "ORDER"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 4,
    "question": "다음 중 SQL의 DML(데이터 조작어)이 아닌 것은?",
    "choices": {
      "①": "INSERT",
      "②": "UPDATE",
      "③": "DELETE",
      "④": "DROP"
    },
    "correct_answer": "④"
  },
  {
    "question_number": 5,
    "question": "SQL에서 정렬 기준을 지정할 때 사용하는 절은?",
    "choices": {
      "①": "SORT BY",
      "②": "GROUP BY",
      "③": "ORDER BY",
      "④": "ARRANGE BY"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 6,
    "question": "SQL에서 테이블을 삭제하는 명령어는?",
    "choices": {
      "①": "REMOVE TABLE",
      "②": "DROP TABLE",
      "③": "DELETE TABLE",
      "④": "CLEAR TABLE"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 7,
    "question": "SQL에서 NULL 값에 대한 조건을 지정할 때 사용하는 구문은?",
    "choices": {
      "①": "IS NULL",
      "②": "= NULL",
      "③": "EQUAL NULL",
      "④": "HAS NULL"
    },
    "correct_answer": "①"
  },
  {
    "question_number": 1,
    "question": "정규화의 주요 목적 중 하나는?",
    "choices": {
      "①": "데이터 중복 최소화",
      "②": "질의 속도 저하",
      "③": "비정규형 유지",
      "④": "데이터 구조 복잡화"
    },
    "correct_answer": "①"
  },
  {
    "question_number": 2,
    "question": "제1정규형(1NF)을 만족하기 위한 조건은?",
    "choices": {
      "①": "모든 속성 값이 NULL일 수 있음",
      "②": "반복 속성이 없어야 함",
      "③": "부분 함수 종속 제거",
      "④": "이행적 함수 종속 제거"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 3,
    "question": "다음 중 제2정규형(2NF)의 특징으로 옳은 것은?",
    "choices": {
      "①": "기본키에 이행적 종속을 가짐",
      "②": "부분 함수 종속을 제거함",
      "③": "모든 속성이 기본키가 아님",
      "④": "비이행 함수 종속을 제거함"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 4,
    "question": "이행적 함수 종속을 제거하는 정규형은?",
    "choices": {
      "①": "제1정규형",
      "②": "제2정규형",
      "③": "제3정규형",
      "④": "BCNF"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 5,
    "question": "정규화와 반정규화의 차이점으로 옳은 것은?",
    "choices": {
      "①": "정규화는 질의 성능 향상을 위한 기법이다",
      "②": "반정규화는 데이터 중복을 제거한다",
      "③": "정규화는 설계 초기, 반정규화는 성능 고려 시 적용된다",
      "④": "정규화는 데이터 무결성을 낮춘다"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 6,
    "question": "BCNF(Boyce-Codd Normal Form)의 특징으로 알맞은 것은?",
    "choices": {
      "①": "모든 결정자가 후보키여야 한다",
      "②": "모든 속성이 NULL 가능",
      "③": "중복 속성이 존재함",
      "④": "반복 그룹 허용"
    },
    "correct_answer": "①"
  },
  {
    "question_number": 7,
    "question": "다음 중 정규화의 필요성이 가장 큰 상황은?",
    "choices": {
      "①": "데이터가 매우 단순한 경우",
      "②": "중복이 많고 갱신 이상이 발생하는 경우",
      "③": "데이터가 항상 불변인 경우",
      "④": "단일 테이블로 모든 처리가 가능한 경우"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 1,
    "question": "다음 중 테이블의 정의로 가장 적절한 것은?",
    "choices": {
      "①": "데이터를 시각화하는 도구",
      "②": "행과 열로 구성된 데이터 저장 구조",
      "③": "SQL 실행 결과",
      "④": "테이블 간 관계를 지정하는 키"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 2,
    "question": "뷰(View)의 특징으로 옳은 것은?",
    "choices": {
      "①": "데이터를 실제로 저장한다",
      "②": "하나의 뷰는 여러 테이블을 결합할 수 없다",
      "③": "논리적 가상 테이블이다",
      "④": "뷰는 갱신될 수 없다"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 3,
    "question": "다음 중 인덱스(Index)의 주요 목적은?",
    "choices": {
      "①": "데이터 삭제 속도 향상",
      "②": "데이터 백업 최적화",
      "③": "검색 성능 향상",
      "④": "데이터 중복 방지"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 4,
    "question": "시퀀스(Sequence)의 역할로 옳은 것은?",
    "choices": {
      "①": "트랜잭션 관리",
      "②": "자동 번호 생성",
      "③": "보안 정책 설정",
      "④": "데이터 무결성 검사"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 5,
    "question": "뷰(View) 생성에 사용되는 SQL 명령은?",
    "choices": {
      "①": "CREATE VIEW",
      "②": "CREATE TABLE",
      "③": "CREATE INDEX",
      "④": "CREATE TRIGGER"
    },
    "correct_answer": "①"
  },
  {
    "question_number": 6,
    "question": "다음 중 저장 객체에 해당하지 않는 것은?",
    "choices": {
      "①": "테이블",
      "②": "시퀀스",
      "③": "트랜잭션",
      "④": "인덱스"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 7,
    "question": "다음 중 인덱스를 자동으로 생성하는 경우는?",
    "choices": {
      "①": "VIEW 생성 시",
      "②": "기본키 제약 조건 설정 시",
      "③": "트랜잭션 커밋 시",
      "④": "테이블 삭제 시"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 1,
    "question": "데이터베이스에서 파일 구조의 주된 목적은?",
    "choices": {
      "①": "검색 속도 향상",
      "②": "데이터 삭제 보장",
      "③": "화면 출력 최적화",
      "④": "사용자 인증"
    },
    "correct_answer": "①"
  },
  {
    "question_number": 2,
    "question": "고정 길이 레코드의 특징으로 가장 적절한 것은?",
    "choices": {
      "①": "각 레코드의 길이가 다르다",
      "②": "공간 낭비가 없다",
      "③": "레코드 접근 속도가 빠르다",
      "④": "길이 지정이 필요 없다"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 3,
    "question": "가변 길이 레코드에서 발생할 수 있는 주요 문제는?",
    "choices": {
      "①": "디스크 공간의 과잉 소비",
      "②": "빈번한 재정렬",
      "③": "접근 시간 증가",
      "④": "데이터 무결성 강화"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 4,
    "question": "데이터 파일의 유형이 아닌 것은?",
    "choices": {
      "①": "순차 파일",
      "②": "해시 파일",
      "③": "색인 순차 파일",
      "④": "논리 파일"
    },
    "correct_answer": "④"
  },
  {
    "question_number": 5,
    "question": "색인 순차 파일(ISAM)의 장점으로 알맞은 것은?",
    "choices": {
      "①": "색인을 사용하지 않음",
      "②": "실시간 삽입에 유리함",
      "③": "순차 및 직접 접근이 모두 가능함",
      "④": "해시 테이블 기반 접근 지원"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 6,
    "question": "데이터 파일의 블록 단위 처리를 통해 얻을 수 있는 효과는?",
    "choices": {
      "①": "속도 저하",
      "②": "입출력 효율 향상",
      "③": "파일 손상 방지",
      "④": "보안 강화"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 7,
    "question": "파일 조직 방법 중 해시 기법의 특징은?",
    "choices": {
      "①": "순차 탐색 기반",
      "②": "색인 중심 접근",
      "③": "해시 함수에 의해 직접 주소 계산",
      "④": "B-트리 기반 정렬"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 1,
    "question": "인덱스를 사용하는 주요 목적은?",
    "choices": {
      "①": "데이터 백업",
      "②": "검색 성능 향상",
      "③": "데이터 무결성 강화",
      "④": "테이블 병합"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 2,
    "question": "클러스터형 인덱스의 특징은?",
    "choices": {
      "①": "인덱스가 별도의 공간에 저장됨",
      "②": "레코드가 물리적으로 정렬되지 않음",
      "③": "데이터가 인덱스 순서에 따라 저장됨",
      "④": "중복 값만 인덱싱"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 3,
    "question": "다중 레벨 인덱스의 장점으로 옳은 것은?",
    "choices": {
      "①": "더 많은 디스크 공간 사용",
      "②": "검색 효율 저하",
      "③": "검색 속도 향상",
      "④": "색인 순차 파일 전용"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 4,
    "question": "비클러스터형 인덱스의 특징은?",
    "choices": {
      "①": "데이터가 인덱스 순서에 따라 저장됨",
      "②": "중복 키를 허용하지 않음",
      "③": "인덱스와 데이터가 분리되어 있음",
      "④": "레코드가 정렬됨"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 5,
    "question": "해싱 기법의 핵심 요소는?",
    "choices": {
      "①": "보안 알고리즘",
      "②": "키값 분산 저장",
      "③": "트리 기반 탐색",
      "④": "데이터 압축"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 6,
    "question": "해시 충돌을 처리하기 위한 방법이 아닌 것은?",
    "choices": {
      "①": "체이닝",
      "②": "오픈 주소법",
      "③": "리버스 매핑",
      "④": "더블 해싱"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 7,
    "question": "B-트리 인덱스의 특징으로 가장 적절한 것은?",
    "choices": {
      "①": "균형이 맞지 않은 트리 구조",
      "②": "삽입/삭제 시 정렬되지 않음",
      "③": "모든 리프 노드가 같은 레벨에 존재",
      "④": "키 값 중복 불가능"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 1,
    "question": "트랜잭션의 특성 중 '원자성(Atomicity)'의 의미는?",
    "choices": {
      "①": "모든 작업이 전부 수행되거나 전혀 수행되지 않아야 함",
      "②": "하나의 트랜잭션이 여러 사용자에게 동시에 적용됨",
      "③": "트랜잭션은 항상 동시에 실행됨",
      "④": "트랜잭션은 롤백이 불가능함"
    },
    "correct_answer": "①"
  },
  {
    "question_number": 2,
    "question": "트랜잭션의 일관성(Consistency)은 무엇을 의미하는가?",
    "choices": {
      "①": "트랜잭션 실행 중 상태를 저장함",
      "②": "시스템 오류 발생 시 자동 복구됨",
      "③": "DB가 무결성 제약조건을 항상 만족함",
      "④": "데이터가 중복 저장됨"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 3,
    "question": "트랜잭션의 '격리성(Isolation)'이 보장되지 않으면 발생하는 문제는?",
    "choices": {
      "①": "무결성 위반",
      "②": "병행 제어 실패",
      "③": "일관된 데이터 처리",
      "④": "동시성 이상 현상"
    },
    "correct_answer": "④"
  },
  {
    "question_number": 4,
    "question": "트랜잭션이 완전히 실행된 후 그 결과가 영구히 반영되는 특성은?",
    "choices": {
      "①": "격리성",
      "②": "원자성",
      "③": "지속성",
      "④": "회복성"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 5,
    "question": "동시성 제어 기법 중 로킹(Locking)의 역할은?",
    "choices": {
      "①": "데이터를 삭제하는 기능",
      "②": "트랜잭션을 정지시키는 기능",
      "③": "동시 접근 시 데이터의 일관성 유지",
      "④": "자동 백업 수행"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 6,
    "question": "다음 중 교착 상태(Deadlock)의 예방 기법으로 적절한 것은?",
    "choices": {
      "①": "트랜잭션 재실행 금지",
      "②": "자원 점유 순서 고정",
      "③": "모든 트랜잭션 즉시 종료",
      "④": "백업 없이 실행"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 7,
    "question": "병행 제어 중 낙관적 기법의 특징은?",
    "choices": {
      "①": "트랜잭션 실행 중 지속적인 검사 수행",
      "②": "트랜잭션 종료 시 일괄 검사",
      "③": "항상 데이터 복제 사용",
      "④": "입력 순서 기준 처리"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 1,
    "question": "데이터베이스 보안의 주된 목적은?",
    "choices": {
      "①": "시스템 속도 향상",
      "②": "정확한 백업 수행",
      "③": "데이터 접근 통제 및 보호",
      "④": "물리적 저장소 확보"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 2,
    "question": "접근 제어에서 권한을 가장 세밀하게 관리할 수 있는 방식은?",
    "choices": {
      "①": "사용자 기반 제어",
      "②": "직책 기반 제어",
      "③": "MAC 방식",
      "④": "DAC 방식"
    },
    "correct_answer": "④"
  },
  {
    "question_number": 3,
    "question": "데이터베이스 회복의 정의로 올바른 것은?",
    "choices": {
      "①": "손실된 데이터를 암호화하는 것",
      "②": "손상된 데이터를 초기 상태로 복구하는 것",
      "③": "불필요한 데이터를 제거하는 것",
      "④": "불법 접근을 차단하는 것"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 4,
    "question": "다음 중 트랜잭션 장애에 해당하지 않는 것은?",
    "choices": {
      "①": "논리적 오류",
      "②": "시스템 충돌",
      "③": "디스크 파손",
      "④": "사용자 오류"
    },
    "correct_answer": "③"
  },
  {
    "question_number": 5,
    "question": "데이터베이스 보안 위협 중 내부 위협에 해당하는 것은?",
    "choices": {
      "①": "해커의 침입",
      "②": "직원의 무단 조회",
      "③": "바이러스 공격",
      "④": "외부 시스템 오류"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 6,
    "question": "로그 기반 회복 기법의 특징은?",
    "choices": {
      "①": "트랜잭션 기록을 저장하지 않음",
      "②": "트랜잭션 수행 전후 기록을 저장함",
      "③": "파일 시스템 중심 회복 방식",
      "④": "데이터를 자동으로 암호화함"
    },
    "correct_answer": "②"
  },
  {
    "question_number": 7,
    "question": "데이터베이스 백업의 일반적인 목적은?",
    "choices": {
      "①": "데이터 구조 단순화",
      "②": "트랜잭션 종료 방지",
      "③": "장애 발생 시 복구를 위한 데이터 보존",
      "④": "데이터 삭제 자동화"
    },
    "correct_answer": "③"
  }
]